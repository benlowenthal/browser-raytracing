struct BVHNode {
	aabbMin: vec3f, offset: u32,
	aabbMax: vec3f,	triCount: u32
}

struct Tri {
	v0: u32, v1: u32, v2: u32,
	v0n: u32, v1n: u32, v2n: u32,
	v0t: u32, v1t: u32, v2t: u32,
	m: u32
}

struct Material {
	tex: f32,
	rough: f32,
	gloss: f32,
	transparency: f32,
	refIdx: f32
}


@group(0) @binding(0) var<uniform> dimension: vec2f;

@group(0) @binding(1) var frame: texture_storage_3d<r32float, read_write>;

@group(0) @binding(2) var<storage> bvh: array<BVHNode>;
@group(0) @binding(3) var<storage> vert: array<vec3f>;
@group(0) @binding(4) var<storage> normal: array<vec3f>;
@group(0) @binding(5) var<storage> uvs: array<vec2f>;
@group(0) @binding(6) var<storage> tri: array<Tri>;
@group(0) @binding(7) var<storage> mat: array<Material>;

@group(0) @binding(8) var textures: texture_2d_array<f32>;
@group(0) @binding(9) var texSampler: sampler;

@group(0) @binding(10) var<uniform> pos: vec3f;
@group(0) @binding(11) var<uniform> rot: vec3f;

@group(0) @binding(12) var<uniform> lightPos: vec3f;
@group(0) @binding(13) var<uniform> time: f32;
@group(0) @binding(14) var<uniform> accum_frames: u32;


struct Ray {
	start: vec3f,
	dir: vec3f,
	invDir : vec3f
}

struct Return {
	hit: Hit,
	tri: Tri
}

struct Hit {
	t: f32,
	u: f32,
	v: f32
}


fn sampleTexture(coords : vec2f, layer : f32) -> vec3f {
	return textureSampleLevel(textures, texSampler, vec2f(coords.x, 1-coords.y), u32(layer), 0f).xyz;
}

fn intersectBVH(ray : Ray) -> Return {
	var best = Hit(1e30f, 0f, 0f);
	var hitIdx = 0u;

	var stack = array<u32, 32>();
	var head = 0i;
	stack[head] = 0u;

	while (head > -1i) {
		let pop = bvh[stack[head]];
		head--;

		if (pop.triCount > 0) {
			for (var i = pop.offset; i < pop.offset + pop.triCount; i++) {
				let test = intersectTri(ray, tri[i]);
				if (test.t < best.t) {
					best = test;
					hitIdx = i;
				}
			}
		} else {
			let dist1 = intersectAABB(ray, best.t, bvh[pop.offset].aabbMin, bvh[pop.offset].aabbMax);
			let dist2 = intersectAABB(ray, best.t, bvh[pop.offset+1].aabbMin, bvh[pop.offset+1].aabbMax);

			if (dist1 < dist2) {
				if (dist2 < 1e30f) {
					head++;
					stack[head] = pop.offset + 1;
				}
				head++;
				stack[head] = pop.offset;
			} else {
				if (dist1 < 1e30f) {
					head++;
					stack[head] = pop.offset;
				}
				if (dist2 < 1e30f) {
					head++;
					stack[head] = pop.offset + 1;
				}
			}
		}
	}

	return Return(best, tri[hitIdx]);
}

fn intersectAABB(ray : Ray, dist : f32, bmin : vec3f, bmax : vec3f) -> f32 {
	let tx1 = (bmin.x - ray.start.x) * ray.invDir.x;
	let tx2 = (bmax.x - ray.start.x) * ray.invDir.x;
	let ty1 = (bmin.y - ray.start.y) * ray.invDir.y;
	let ty2 = (bmax.y - ray.start.y) * ray.invDir.y;
	let tz1 = (bmin.z - ray.start.z) * ray.invDir.z;
	let tz2 = (bmax.z - ray.start.z) * ray.invDir.z;

	let tmin = max(max(min(tx1, tx2), min(ty1, ty2)), min(tz1, tz2));
	let tmax = min(min(max(tx1, tx2), max(ty1, ty2)), max(tz1, tz2));

	if (tmax >= tmin && tmin < dist && tmax > 0f) { return tmin; }
	return 1e30f;
}

fn intersectTri(ray : Ray, tri : Tri) -> Hit {
	let miss = Hit(1e30f, 0f, 0f);
	let edge1 = vert[tri.v1] - vert[tri.v0];
	let edge2 = vert[tri.v2] - vert[tri.v0];
	let h = cross(ray.dir, edge2);
	let a = dot(edge1, h);
	if (a > -0.0001f && a < 0.0001f) { return miss; }
	let f = 1 / a;
	let s = ray.start - vert[tri.v0];
	let u = f * dot(s, h);
	if (u < 0f || u > 1f) { return miss; }
	let q = cross(s, edge1);
	let v = f * dot(ray.dir, q);
	if (v < 0f || u + v > 1f) { return miss; }
	let t = f * dot(edge2, q);
	if (t > 0.0001f) { return Hit(t, u, v); }
	return miss;
}

fn random(v: vec3f) -> f32 {
	//random float between 0, 1
	var m = hash(bitcast<u32>(v.x)) ^ hash(bitcast<u32>(v.y)) ^ hash(bitcast<u32>(v.z));
	const ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32
    m &= ieeeMantissa;                // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                     // Add fractional part to 1.0
    return bitcast<f32>(m) - 1.0;     // Range [0:1]
}

fn hash(in: u32) -> u32 {
	var x = in;
	x += x << 10u;
    x ^= x >> 6u;
    x += x << 3u;
    x ^= x >> 11u;
    x += x << 15u;
    return x;
}

fn lightTest(hitPnt: vec3f, intensity: f32, seed: vec3f) -> f32 {
	let dir = lightPos - hitPnt;
	let lightDist = length(dir) - 0.0001f;
	let lightDir = normalize(dir + random(seed) * 0.2f);
	let lightRay = Ray(hitPnt + dir * 0.0001f, lightDir, 1 / lightDir);
	let lightOut = intersectBVH(lightRay);
	if (lightOut.hit.t > lightDist) { return intensity / lightDist; }
	let hitMat = mat[lightOut.tri.m];
    return max((intensity * hitMat.transparency) / lightDist, 0);
}

@compute @workgroup_size(8,8)
fn computeMain(@builtin(global_invocation_id) globalIdx: vec3u) {
	const ambient = vec3f(0.5, 0.55, 0.65);
	const samples = 1u;
	const bounces = 5u;

	let uv = vec3f(globalIdx);
	var seed = vec3f(uv.xy, time);

	let right = normalize(cross(vec3f(0, 1, 0), rot));
	let up = normalize(cross(rot, right));

	let ratio = dimension.y / dimension.x;
	let screenPos = vec2f(uv.x/(dimension.x/2f) - 1f, (1f - uv.y/(dimension.y/2f)) * ratio);

	let dir = normalize(rot + screenPos.x * right + screenPos.y * up);

	let dir2 = normalize(rot + (screenPos.x-0.001f) * right + screenPos.y * up);
	let dir3 = normalize(rot + (screenPos.x+0.001f) * right + screenPos.y * up);
	let dir4 = normalize(rot + screenPos.x * right + (screenPos.y-0.001f) * up);
	let dir5 = normalize(rot + screenPos.x * right + (screenPos.y+0.001f) * up);

	var rays = array<Ray, 5>(Ray(pos, dir, 1 / dir),Ray(pos, dir2, 1 / dir2),Ray(pos, dir3, 1 / dir3),Ray(pos, dir4, 1 / dir4),Ray(pos, dir5, 1 / dir5));

	//accumulate samples per pixel
	var total = vec3f(0);
	for (var s = 0u; s < samples; s++) {
		var ray = rays[s];
		var color = vec3f(0);
		var throughput = vec3f(1);

		for (var bounce = 0u; bounce < bounces; bounce++) {
			let out = intersectBVH(ray);

			//ray missed all primitives
			if (out.hit.t > 1e20f) {
				color += throughput * ambient;
				break;
			}
	

			let bary = vec3f(1 - out.hit.u - out.hit.v, out.hit.u, out.hit.v);
			let material = mat[out.tri.m];

			let texUV = uvs[out.tri.v0t] * bary.x + uvs[out.tri.v1t] * bary.y + uvs[out.tri.v2t] * bary.z;
			let texColor = sampleTexture(texUV, material.tex);


			//emissive material override
			if (material.refIdx < 0) {
				color += throughput * texColor * -material.refIdx * 2;
				break;
			}


			let hitPnt = ray.start + ray.dir * out.hit.t;
			let norm = normalize(normal[out.tri.v0n] * bary.x + normal[out.tri.v1n] * bary.y + normal[out.tri.v2n] * bary.z);
			let diffuse = 1 - material.transparency;
		
			//direct light testing
			var light = 1f;
			if (random(seed * 0.999) < diffuse) { light = lightTest(hitPnt, 8, seed * 1.002); }
			color += throughput * texColor * diffuse * light;


			//choose one interaction
			let r = random(seed * 1.002);
			var newDir: vec3f;


			//schlick approx. for fresnel
			let F0 = material.gloss;
			let theta = dot(-ray.dir, norm);
			let fresnel = (F0 + (1 - F0) * pow(1 - abs(theta), 5)) * (1 - material.rough);

			if (r < fresnel) {
				newDir = reflect(ray.dir, norm);
				throughput *= texColor / fresnel;
			}

			else {
				let r2 = random(seed * 0.997);

				//diffuse
				if (r2 < diffuse) {
					//cosine hemisphere sampling
					let a = random(seed * 1.003) * 6.2831853;	//angle in radians
					let z = random(seed * 1.004) * 2 - 1;		//z from -1 to 1
					let r = sqrt(max(0.0, 1.0 - z * z));
					newDir = normalize(norm + vec3f(r * cos(a), r * sin(a), z));
					throughput *= texColor / (diffuse * (1 - fresnel));
				}

				//refract
				else{
					let ior = material.refIdx;

					//entering material
					if (dot(-ray.dir, norm) > 0) {
						newDir = refract(ray.dir, norm, 1 / ior);
						throughput *= texColor;
					}

					//exiting material
					else {
						let theta = dot(-ray.dir, -norm);
						let k = ior * ior * (1.0 - theta * theta);

						if (k > 1) { newDir = reflect(ray.dir, -norm); }	//total internal reflection
						else { newDir = refract(ray.dir, -norm, ior); }		//refraction

						//beer-lambert absorption
						let absorbColor = log(texColor);
						throughput *= exp(-absorbColor * out.hit.t * 0.1);
					}
				
					throughput *= 1 / (material.transparency * (1 - fresnel));
				}

			}

			newDir = normalize(newDir);
			ray = Ray(hitPnt + newDir * 0.0001f, newDir, 1 / newDir);


			//terminate low energy paths
			var p = max(max(throughput.x, throughput.y), throughput.z);
			p = clamp(p, 0.0001, 0.9999);
			if (random(seed * 1.005) > p) { break; }
			throughput /= p; //compensate for lost rays

			throughput = min(throughput, vec3f(10));
			seed *= 1.01;
		}
		total += color;
		seed *= 0.99;
	}

	let ij = vec2u(u32(uv.x), u32(uv.y));
	let prevColor = vec3f(textureLoad(frame, vec3u(ij, 0u)).x, textureLoad(frame, vec3u(ij, 1u)).x, textureLoad(frame, vec3u(ij, 2u)).x);

	total = (prevColor * f32(accum_frames * samples) + total) / f32((accum_frames + 1) * samples);

	textureStore(frame, vec3u(ij, 0u), vec4f(total.r, 0, 0, 1));
	textureStore(frame, vec3u(ij, 1u), vec4f(total.g, 0, 0, 1));
	textureStore(frame, vec3u(ij, 2u), vec4f(total.b, 0, 0, 1));
}

@vertex
fn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {
	return vec4f(pos, 0, 1);
}

@fragment
fn fragmentMain(@builtin(position) uv: vec4f) -> @location(0) vec4f {
	let ij = vec2u(u32(uv.x), u32(uv.y));

	let color = vec3f(textureLoad(frame, vec3u(ij, 0u)).x, textureLoad(frame, vec3u(ij, 1u)).x, textureLoad(frame, vec3u(ij, 2u)).x);

	let up = vec3f(textureLoad(frame, vec3u(ij.x, ij.y+1, 0u)).x, textureLoad(frame, vec3u(ij.x, ij.y+1, 1u)).x, textureLoad(frame, vec3u(ij.x, ij.y+1, 2u)).x);
	let down = vec3f(textureLoad(frame, vec3u(ij.x, ij.y-1, 0u)).x, textureLoad(frame, vec3u(ij.x, ij.y-1, 1u)).x, textureLoad(frame, vec3u(ij.x, ij.y-1, 2u)).x);
	let left = vec3f(textureLoad(frame, vec3u(ij.x-1, ij.y, 0u)).x, textureLoad(frame, vec3u(ij.x-1, ij.y, 1u)).x, textureLoad(frame, vec3u(ij.x-1, ij.y, 2u)).x);
	let right = vec3f(textureLoad(frame, vec3u(ij.x+1, ij.y, 0u)).x, textureLoad(frame, vec3u(ij.x+1, ij.y, 1u)).x, textureLoad(frame, vec3u(ij.x+1, ij.y, 2u)).x);

	//ACESFilm tonemapping
	const a = 2.51f;
	const b = 0.03f;
	const c = 2.43f;
	const d = 0.59f;
	const e = 0.14f;

	let x = (4 * color + up + down + left + right) / 8;
	return vec4f(saturate((x*(a*x+b))/(x*(c*x+d)+e)), 1);
}